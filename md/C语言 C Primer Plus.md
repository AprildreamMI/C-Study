# C语言 C 

## 第一章

### 使用C语言的7个步骤

#### 第一步：定义程序的目标

#### 第二步：设计程序

#### 第三步:   编写代码

#### 第四步：编译代码

​	通过以下的操作操作，生成一个用户可以运行的可执行文件

##### 编译器

​	编译器就是把源代码转换成可执行代码的程序

> 可执行代码使用计算机的及其语言表示的代码，这种语言有数字表示的指令组成

##### 连接器

​	C编译器还将源代码与C库的代码合并成最终的程序

> 应该是有一个被称为链接器的程序来链接库函数

#### 第五步：运行

### 目标代码文件、可执行文件、库

> c 语言的策略是把源代码变成为可执行文件
>
> 进行编译生成  中间代码   并且通过链接器来链接其他库文件，其他的库文件也是中间代码，合并后，生成可执行文件

#### 目标代码文件（中间代码的一种表现形式）

​	把源代码转换成机器语言代码，并把结果放在目标代码文件，后缀为.obj文件

##### 虽然包含机器代码：并不能直接运行	

> 因为目标文件存储的是编译器翻译的源代码，这还不是一个完成的程序

+ 缺失启动代码，启动代码充当程序与操作系统中间的接口
+ 缺失库函数， 只是包含了使用库函数的指令，真正的代码，存储在另外一个被称为库的文件中

#### 库

​	函数库，库文件中有许多函数的目标代码

#### 可执行文件

> 后缀为.exe文件

##### 链接器的作用

链接

+ 自己编写的代码通过编译器转换的目标代码

+ 系统的标准启动代码

+ 库代码

  > 对于库代码，链接器指挥吧程序中要用到的库函数提取出来

合并，为一个文件  可执行文件

#### 目标代码文件和可执行代码文件的对比

##### 相同点

+ 目标代码文件和可执行代码文件都有机器语言指令组成

区别

+ 目标代码文件中只包含编译器为你自己编译的机器语言代码
+ 可执行文件中还包含你编写的程序中使用的库函数和启动代码的机器代码

### 变量的命名

#### 规则

​	 可以使用大小写字母，数字和下划线来命名，并且，名称的第一个字符必须是字符或下划线，不能是数字（不能是特殊的符号）

+ &a           -------> 错误
+ FOR         -------> 正确 C语言区分大写小写
+ __00         -------> 正确

## 第三章

### 八进制和十六进制

#### 十六进制

+ 0x 或 0X前缀表示十六进制

### 八进制

+ 0 是八进制
+ 八进制中没有数字8

### 各类进制显示

> 如果要显示的打印前缀， 则需要在%后面加一个#号
>
> %#o
>
> %#x
>
> %#X

+ 十进制

  > %d

+ 八进制

  > %o

+ 十六进制

  > %x

#### 各整数类型

> 带** 号的都是有符号的类型

+ ** int

  > 16位或者32位
  >
  > 根据计算机的自然字长而定

+ ** short int 类型  

  > 16

+ ** long int

  > 32

+ ** long long int

  > 该类型至少占64位

+ unsigned int   || unsigned

  > 非负数 无符号整形
  >
  > 他可以比有符号的表示更大的数
  >
  > 0 ~ 65535

+ signed 

  > 在任何类型前 加上其 表示 强制使用有符号

### 各类型的打印格式

+ unsigned

  > %u

+ long int

  > %ld
  >
  > 还可以通过八进制和十六进制来表示Long int 
  >
  > 在转换说明汇总， 只能用小写

  + 八进制 Long

    %lo

  + 十六进制 Long

    %lx

+ long long 

  > %lld

+ short 

  > %hd

+ unsigned long

  > %lu

### char

> 一字节 === 8位

char 占一字节八位存储单元

#### 字符变量在C语言中被视为 int 类型， 而不是 char 类型

```
char myChar  = 'A' // 'A' 字符变量在ASCII 表中是65， 所以是int 类型
```

### float

#### 范围

10-37 ~ 10+37

#### 有效数字

foat 类型必须能够表示33。333333的前六位数字，而不是精确到小输掉后六位

### double

#### 范围

10-37 ~ 10+37

#### 有效数字

doble 类型必须能够表示33。3333333333的前 十 位数字，而不是精确到小输掉后六位

### 浮点型常量

> 默认情况下，编译器假定浮点型常量是double 类型的精度
>
> ```c
> // 加色some 是float类型的变量
> float some = 4.0 * 2.0;
> /*
> 	通常，4.0 和 2.0 被储存为双精度的double 类型
> 	使用双精度进行还曾发运算，然后将乘积截断，成float
> 	在浮点书后面加上f 或者 F ，来覆盖默认的double
> */
> a = 5.22F
> 
> d = 5.33L // 双精度的表示6+
> ```
>

### 小数形式

> 小数形式表示的实型常量必须要有小数点

### 指数形式

> 以E或者e后跟这一个整数来表示以10为底数的冥数，且规定字母e或E之前必须要有数组，且e或E之后的指数必须为整数

## 第四章

### 字符串

> C 语言中没有专门用于存储字符串的变量类型，字符串都被存储在char类型的数组中、

#### 空字符

> 数组的末尾位置，是 '\0'，这是空字符， 表示结尾 ASCII 妈等于 0

+ C语言中的字符串一定一空字符结尾
+ 数组的容量必须至少比带存储字符串中的字符数多1,

#### 字符穿和字符

##### 区别

+ ‘x' 是基本类型，“x”是派生类型（char 数组）
+ “x” 实际上由两个字符组成，’x' 和 '\0'

#### Strlen() 函数

> Strlen () 函数，给出字符串中的字符长度

##### sizeof() 运算符

> 他以字节为单位，输出对象的大小

#### 实列

```
#define pw asdzxc456
char name[40];

输入：zhaosi lvmi

// 虽然输入了8个字符，但因为在字符数组中存储时，中间有一个空字符，所以就中断了计数，
// 只计算空字符前的字符
strlen(name): 4
// 因为字符数组中定义的是40个字节，一个字符占用一字节
sizeof(name): 40

// 遇到空字符就停止计数
strlen(pw): 9
// 多了一个空字符的字节
sizeof(pw): 10
```

```
// 对于中文 一个中文占用两个字符，也就是两个字节
对于name输入： 赵思

strlen(name): 4
```

### #define 预处理器

```c
#define age 22
/*
	编译程序的时候，程序中所有的age将被替换成22
	这一过程叫i做
	编译时替换
	如此定义变量，也叫
	明示变量
*/
```

### printf () 和 scanf() 函数

#### printf() 函数

```
printf("字符串为：%c, 整形数字为%d", '$', 2 * 10);
/*
	像%c,这类，叫做 转换说明，逗哈之后的值，是待打印项列表
	printf待打印项列表使用的是值，无论变量还是常量
*/
```

#### 修饰符合标记

```
-： 左对齐
+： 显示正负号
空格： 正号就是空格， 负号就是-
#： 转换成另外一种形式的写法，如果是%o， 就转换为0开头的，如果是%x则转换为ox开头的
0: 对数值格式，使用0来代替空格填充字段宽度
```

#### scanf() 函数

> 返回成功读取项的数量

##### 跳过空白匹配

scanf() 函数使用空白（换行符，制表符合空格）把输入分成多个字段，再一次把转换说明和字段匹配时跳过空白，

##### scanf()读取一个%d整数的过程

###### 假设scanf() 根据%d的转换说明读取一个整数，

- scanf()每次读取一个字符，跳过所有的空白字符，直到遇到第一个非空白字符才开始读取
- 因要读取整数，所以scanf()希望发现一个数字字符或者一个符号[+、-]
- 如果找到一个字符是数字，它便保存改数字并读取下一个字符，不断的读取和保存字符，直至遇到非数字的字符
- 如果遇到一个非数字的字符，它便认为读取到了整数的结尾，
- 然后，scanf() 把非数字字符放回输入
- 这意味着程序下一次读取输入时，首先读到的是上一次读取丢弃的非数字字符
- 最后，scanf() 计算已读取数字的相应数值，并将计算后的值放入指定的变量中

##### scanf() 读取一段字符串%s

空格后的字符串读取不到

```c
char s[81];

scanf("%s", s);   > dadwada dwadada

printf("%s\n", s);  > dadwada
```



##### scnaf()和printf()中*的使用

> 在printf()中使用通过变量定义输出的字段宽度

```
#include <stdio.h>
int main(void) {
  unsigned width, precision;
  int number = 256;
  double weight = 242.5;

  printf("请输入字段宽度：\n");
  scanf("%d", &width);
  printf("number:%*d\n", width, number);

  printf("请输入字段宽度和小数点精度：\n");
  scanf("%d %d",&width, &precision);
  printf("Weight = %*.*f\n", width, precision, weight);


  return 0;
}
```

> scanf() 中使用，则为定义了*的转换格式跳过

```
  int n;
  printf("程序会跳过两个输入，使用最后一个输入赋值给n：");

  scanf("%*d %*d %d", &n);
  printf("N的值为: %d", n);
```

## 第八章 字符输入/输出和输入验证

### io函数

> printf()、scanf()、getchar()、putchar()、·-

#### getchar()

返回值：int类型

如果把getchar()的返回值赋给char类型的变量，以谢编译器会警告可能丢失数据

getchar() 读取每个字符，包括空格、制表符和换行符，而scanf()在读取数字指定的行数和列99数打印该字符

## 第十章

### 数组

> + 数组的维数必须是常量、不能用变量来当作数组的维数
>
>   而C99做了很大改进，允许数组的[ ]中的值是整形变量或是整形表达式
>
> + 数组定义后，不可以对数组整体赋值

#### 指定初始化器

```
// 可以在初始化列表中使用带方括号的下标指明待初始化的元素
int arr[6] = {[5] = 212};
// 把arr[5] 初始化为212
对于一般的初始化，在初始化一个元素后，为初始化的元素都会被设置为0

如果未指定元素大小会如何？
int stuff[] = {1, 2, 3, [6] = 23}
int staff[] = {1, [6] = 4, 9, 10}

编译器会把数组的大小设置未足够装得下初始化的值，所以，stuff数组有7个元素，编号围殴0 ~ 6，
而staff数组的元素比stuff数组多两个
```

C不允许把数组作为一个单元付给另外一个数组，除非初始化以外页不允许使用花括号列表的形式赋值

### 数组名是数组首元素的地址

```
/*
	flizny 和 &fizny[0] 都表示数组首元素的内存地址，两者都是常量
*/
flizny == &fizny[0]
```

### 指针 + 1 , 实际上是增加了一个存储单元

> 指针的值递增它所指向类型的大小（以字节为单位）

```
short dates[5];
short * pti

// 把数组地址复制给指针
pti = dataes;

pti + 0: 0x7fff5fbff8dc
pti + 1: 0x7fff5fbff8de
pti + 2: 0x7fff5fbff8e0
pti + 3: 0x7fff5fbff8e2
```

​	在我们系统中，地址按字节编址 short 类型占用2字节

​	在C语言中 指针 + 1 就是增加一个存储单元，对数组而言，这意味着把 + 1 后的地址是下一个元素的地址，而不是下一个字节的地址

#### 自增指针指向

```
total += *start++

一元运算符*和++的优先级相同，但结合律收从右往左，所以start++先求值，然后才是*start，也就是说，执政start先递增后只想，但由于使用后缀表达式，意味着先把执政只想位置上的值加到total上，然后再递增指针，如果使用*++start,则相反，先递增指针，再使用指针指向位置上的值，如果使用（*start）++，则先使用start指向的值，再递增该值，而不是递增指针
虽然*start++的写法比较常见，但是*（start++）这样写更清楚，
```



### 使用const 来保护数据 以及和数组、 指针的关系

#### const 关键字保护数组

```
const int days[5] = {1, 2, 3, 4, 5}

// 编译出错. 不允许更改
days[2] = 44;
```

#### 指向const 的指针不能用于改变他所指向的地址中的值，但是可以修改指向地址（指向别处）

> void show_array(const * pd, int end)
>
> 表明该函数不会使用指针改变数据

```
double rates[5] = {1, 2, 3, 4, 5}
// pd 指向数组的首元素 
// 把pd 指向的double 类型的值声明为const 
const double * pd = rates;

*pd = 29.89   // 不允许, 企图修改首地址的值 
pd[2] = 222.22   // 不允许，因为pd相当于就是首地址，相当于rates ，编译器不允许通过这种方式来进行修改
rates[0] = 99.99  // 允许
pd++              // 允许
```

#### 把const 数据 或 非 const 数据的地址初始化为指向const 的指针或为其赋值是合法的

```
double rates[5] = {1, 2, 3, 4, 5}
const double locked[4] = {0.08, 0.075, 0.0512, 0.611}

const double * pc = rates   // 合法
pc = locked    				// 合法
pc = &rates[3]				// 合法
```

#### 只能把非const 的数据赋给普通指针

> 否则， 通过指针就能改变const 关键字的数据

```
double rates[5] = {1, 2, 3, 4, 5}
const double locked[4] = {0.08, 0.075, 0.0512, 0.611}

double * pc = rates   		// 合法
pc = locked    				// 非法
pc = &rates[3]				// 合法
```

#### 声明一个不能修改指向地址的内容并不能改变指向的指针

```
double rates[5] = {1, 2, 3, 4, 5}
const double locked[4] = {0.08, 0.075, 0.0512, 0.611}

const double * const pc = rates   		// 合法
pc = &rates[2]    						// 非法
*pc = 56.56								// 合法
```

### 指针和多位数组

```
int zippo[4][2]    		// 内含int 数组的数组
```

+ 数组名

  > zippo 是该数组首元素的地址

+ 首元素

  > zippo首元素是一个内含两个int 值的数组， 所以 zippo 是这个内含两个int 值的数组的地址

1. 因为zippo是数组首元素的地址，所以zippo的值和&zippo[0]的值相同，

   而zippo[0]是一个内含两个元素的数组, 所以，他又是他的首元素的地址

   所以zippo[0] ==` &zippo[0][0]`

   

   因为，二维数组在内存中也是连续性的存储，列如`int arr[2][2]`

   | `zippo[0][0]` | `zippo[0][1]` | `zippo[1][0]` | `zippo[1][1]` |
   | ------------- | ------------- | ------------- | ------------- |
   |               |               |               |               |

   arr: 是二维数组的首元素是一个一个数组，这个数组存储两个int 类型的元素 所以 其为 8字节（占用两个int 大小对象的地址

   `arr[0]`： 是一维数组的首元素的地址，为一个int 类型的值 （4字节）

2. *zppo: 代表该数组首元素（zippo[0]的值，但是zippo[0] 本身是一个Int 类型的值的地址 == `&zippo[0][0]`）

   所以  *zippo == `&zippo[0][0]`

   所以 对于 `zippo[2][3]` = { {1,2,3}, {2,3,4}}

   zippo == &zippo[0]

   *zippo ==  zippo[0] == `&zippo[0][0]`

   **zippo  = *(`&zippo[0][0]`)  == 1

### 变长数组

> 变长数组不能改变大小
>
> 变长数组中的“变”不是指可以修改已创建数组的大小，一旦创建了变长数组，他的大小则保持不变，这里的变是指，在创建数组时，可以使用变量指定的数组的维度上

## 第十一章

### 字符串数组和初始化

#### 字符串数组和字符数组的区别

字符串数组最后面有一个`‘\0’`所以是字符串数组

而字符数组最后面是没有`‘\0’`的

#### 字符串数组初始化

```c
// 字符串数组
const char ml[40] = "Limit yourself to one line's worth"；
// 让编译器自动计算大小
const char ml[] = "Limit yourself to one line's worth"；
```

> 让编译器自动计算大小只能用在初始化数组时，如果创建一个稍后在填充的数组，就必须在声明时指定大小

#### 指针表示法创建字符串

```
const char * pt1 = "Something is pointing at me"；
```

### 数组表示字符串和指针表示字符串的不同

```C
const char arl[] = "Something is pointing at me";
```

#### 数组形式

1. 在计算机的内存中分配为一个内涵29个元素的数组
2. 每个数组元素被初始化为字符串字面量对应的字符
3. 字符串作为可执行文件的一部分被存储在数据段中，当把程序载入内存时，也载入了程序中的字符串
4. 字符串存储在静态存储区
5. 程序在开始运行时才会为该数组分配内存，此时，才将字符串拷贝到数组中
6. 此时字符串有两个副本，
   1. 在静态内存中的字符串字面量
   2. 存储在ar1数组中的字符串
7. 此后，编译器便把数组名ar1识别为该数组首元素地址别名，在数组形式中，ar1是地址常量，不能更改ar1，如果改变了ar1则意味改变了数组的存储位置
8. 可以进行ar1+1这样的操作，表示数组下一个元素
9. 但不允许ar++这样的操作

#### 指针形式

1. 也使得编译器为字符串在静态存储区预留29个元素的空间
2. 一旦开始执行程序，他就会为指针变量pt1留出一个存储位置，并把字符串的地址存储在指针变量中
3. 改指针变量最初指向改字符串的首字符，但是它的值是可以改变的

### 字符串的输入 fgets() and gets()

##### 注意

​	字符串的输入第一件事要为其分配空间，以存储稍后读入的字符串，然后用输入函数获取该字符串

​	不要指望计算机读取字符串时，顺便计算它的长度，然后在分配空间

``` C
char * name;
scanf("%s", name);
/*
  虽然会通过编译，但在读入name时，name可能会擦写掉程序中的其他数据和代码，从而导致程序崩溃
  因为scanf() 要把信息拷贝至参数指定的地址上，而此时该参数为一个未初始化的指针，name 可能会指向任何地方
*/
```

#### gets ()

> 读取整行输入，直至遇到换行符，然后丢弃换行符，存储其余字符串，并在结尾添加一个空字符 ‘\0’ 以标志结尾

##### 参数

+ 字符数组、

##### 返回

- 因为是读取一个文件
- 一切顺利，文件读完了，则返回一个 null 
- 出现错误， 返回一个 null

##### 处理方法

+ 整行读取，遇到换行符结束
+ 丢弃换行符
+ 存储其余字符
+ 在结尾添加一个 ‘\0’ 标志结尾
+ 无法检查数组是否装得下输入行，只知道数组的开始处，并不知道数组中有多少个元素
+ 输入过长，导入溢出，多余的字符使用了尚未使用了其他内存空间，容易崩溃

#### fgets()

##### 参数

+ 字符数组
+ 读入字符的最大数量，没有读到最大数量，则读到换行符为止
+ 指明要读取的文件，如果不是文件是键盘，则 为 `stdin` 在stdio.h文件中定义

##### 返回

+ 因为是读取一个文件
+ 一切顺利，文件读完了，则返回的地址于传入了的第一个参数的地址相同
+ 出现错误， 返回一个 null

##### 处理方法

+ 整行读取，直到读完遇到null（针对文件）
+ 保存换行符
+ 通过第二个参数来规定读取的最大数量
+ 输入过长，只保留有效字符

#### gets_s()

##### 参数

+ 字符数组
+ 读取字符的最大数量



#### scanf()

##### 参数

+ 转换说明
  + 如果规定了宽度，则按宽度读取或读到的第一个空白字符停止
  + 输入超过了宽度 存入缓冲区，等待下一次读取
+ 需存入的地址

##### 返回

+ 整数：scanf()成功读取到了项数
+ EOF：文件结尾

##### 处理方法

+ 从第一个非空白字符作为开始
+ 遇到的第一个空白字符作为结束

### 字符串的输出

#### puts()

##### 参数

+ 字符串的地址

##### 处理过程

+ 自动在所显示的字符串后面添加一个换行符，因为在gets() 中舍弃换行符

+ 遇到空白符停止

  + ```
    char side_a = ['w', 'a', 'c']；
    // 上字符数组没有空白符 `\0` 所以不会停， 一直向后内存读取，直到遇到一个空白符
    ```

#### fputs()

##### 参数

+ 字符数组（地址）
+ 要写入数据的文件，如果要显示在显示屏上 则传入`stdout`

##### 处理过程

+ 不会添加换行符，因为在fgets() 保留有换行符88



### 字符串函数

> 存放在string.h头文件之中

#### strlen()函数

> 用于拥挤字符串的长度，不包括`\0`的长度

#### strcat()函数

> 用于拼接字符串
>
> 接受两个字符串作为参数，该函数把第2个字符串的备份附加在第一个字符串末尾，并把拼接后形成的新字符串作为第一个字符串，第二个字符串不变

##### 参数

+ 被拼接的字符串
+ 拼接源

##### 返回值

​	char *， 即拼接第二个字符串后的第一个字符串的地址

#### strncat() 函数

> 因为strcat() 无法检查第一个数组是否能容纳第二个字符串

##### 参数

+ 被拼接的字符串

+ 拼接源

+ 最大添加字符数

  > 列入strncat(bugs, addon, 13)，将把addon字符串的内容附加到bugs，在加到地13个字符或遇到空字符时停止

#### strcmp()函数

> 字符串之间的比较
>
> 对比ASCII 值， 值大的在后面，值小的在前面

A => A   >>>>>>  0  相同返回0

A => B >>>>>>> -1  

#### strncmp()函数

> 对比连个字符串，可以比较到字符串不同的地方，也可以之比较到第三个参数指定的字符数，

#### strcpy()函数

> 拷贝字符串到另外一个字符串中

##### 返回类型

> 返回char * ,返回第一个参数的地址，列入
>
> ps = strcpy(chars + 7, origin)
>
> 返回的时数组chars下标为7的元素地址
>
> chars[20] = “zhaosi hahah diqige”
>
> ps === hahah diqige

对字符串进行拷贝的时候，还会把源字符串的空白字符拷贝进去

#### strncpy()函数

> 相比strcpy()函数，存在第三个参数，规定拷贝多少进入目标字符串

如果完全把源字符串拷贝进入了目标字符串，那么最后一个字符就为空字符

否则，就并未空白空字符

#### sprintf()函数

> 该函数可以把多个元素组合成一个字符串，sprintf（）的第一个参数是目标字符串的地址，其余参数和printf()相同，即格式字符串和带写入项的列表

## 第十二章存储类别、连接和内存管理

### 对象

从硬件方面来看，被存储的每个值都占用一定的物理内存，C语言把这样的一块内存成为对象

### 自动变量的初始化

自动变量不会初始化，除非显示的初始化它

```C
int main(void) {
   	int repid;		 // 值为之前占用分配给repid的空间的任意值（如果有的话，别指望此值为0）
   	int tents = 5;   // 初始变量为5
}
```

### 作用域

#### 块作用域

块使用一堆花括号括起来的代码区域，定义在块中的变量具有块级作用域

#### 函数作用域

仅用于goto语句的标签，这意味着即使一个标签首次出现在函数的内层块中，它的作用域也延伸整个函数，

#### 函数原型作用域

用于函数原型中的形参名

```
int mighty(int mouse, double large)
```

#### 文件作用域

> 整个翻译单元可见

变量的定义在函数的外面，具有文件作用域，具有文件作用域的变量，从他的定义出到该定义所在的文件的末尾均可见

```
#include <stdio,h>
int units = 0;  // 块级作用域
int main(void) {
    
    printf("%d\n", units)
}
```

### 翻译单元和文件

多个文件在编译器可能以一个文件出现，列如，通常在源代码.c中包含一个或多个头文件(.h)头文件回一次包含其他文件，所以会包含多个为物理文件，但是C预处理器实际上是用包含的头文件内容替换#include指令，所以，编译器源代码文件和所有的头文件都成是一个包含信息的单独文件，这个文件即为翻译单元

**描述一个具有文件作用域的变量时，它的实际可见范围是整个翻译单元**

**如果程序由多个源代码组成，那么该程序也将由多个翻译单元组成，每个翻译单元均对应一个源代码文件和它所包含的文件**

### 链接

#### 外部链接

+ 文件作用域  多翻译单元使用

  ```c
  int giants = 5;  		  // 文件作用域 外部链接
  static int dodergs = 3 ;  // 文件作用域 外部链接
  int main(void) {
      
      
  }
  ```

#### 内部链接

+ 文件作用域  单翻译单元使用

  ```C
  int giants = 5;  		  // 文件作用域 外部链接
  static int dodergs = 3 ;  // 文件作用域 外部链接
  int main(void) {
      
      
  }
  ```

#### 无连接

+ 块作用域
+ 函数作用域
+ 函数原型作用域

### 存储期

> 作用域和链接描述了标识符的可见性
>
> 存储器描述了通过这些标识符访问的对象的生存期

#### 静态存储期

> 如果对象具有静态存储期，那么他在程序的执行期间一直存在
>
> 无论内部链接还是外部链接的文件作用域，所有的文件作用域变量都是静态存储期

##### 文件作用域具有静态存储期

对于文件作用域，关键字static表明了去链接属性，而非存储期，以static声明的文件作用域变量具有内部链接

#### 线程存储期

> 线程存储期用于并发程序设计，程序执行可被分为多个线程，具有线程存储期的对象，从被声明时到线程结束时一直存在

#### 自动存储期

> 到此位置，我们使用的局部变量都是自动类别
>
> 然而，块作用域也能创建静态存储期的变量，需要把要把变量放在块中，且在声明前面加上关键字static

块作用域的变量通常具有自动存储期，当程序进入定义这些变量的块时，为这些变量分配内存，当退出这个块时，释放刚才为变量分配的内存。

#### 动态分配存储期

### 寄存器变量

> 不能对该变量使用地址运算符。

寄存器变量和自动变量都一样，也就是说，他们都是块作用域，无连接和自动存储期，使用存储类别register便可声明寄存器变量

```C
int main(void) {
    register int quick;
}
// 幸运是指声明变量register类别与直接命令相比，更像是一种请求，编译器必须根据寄存器或最快可用内存数量衡量请求，或者直接忽视请求，在这种情况下寄存器变量就变成了普通的自动变量，即使是这样，任然不能对该变量使用地址运算符。
```

### 块作用域的静态变量

> 静态变量像是一个不可变的变量，实际上不是值不变，而是其再内存中原地不动

+ 如果未显示的初始化静态变量他们被初始化为0
+ 不能再函数的形参中使用static

### 外部链接的静态变量（外部存储类别）

> 外部链接的静态变量具有文件作用域、外部链接和静态存储期、属于该类别的变量被称为外部变量，
>
> 把变量的定义放在所有的函数的外面便创建的外部变量
>
> 为了指出在函数中使用了外部变量，可以在函数中使用关键字extern再次声明，
>
> 如果一个源代码文件使用的外部变量定义在另一个源代码文件中，则必须使用extern在该文件中声明该变量

```C
int Errupt；   		// 外部定义的变量
double Up[100]; 	// 外部定义的数组
extren char Coal;	// 如果Coal被定义在另外一个文件

void next(void);
int main(void) {
    extern int Errupt;   // 可选的声明 
    if (true) {
        extern int Errupt = 22; // 错误的引用声明
    }
    extern double Up[];  // 可选的声明 并且不用指定数组的大小，
}
```

### 内部链接的静态变量

> 该类存储类别的变量具有静态存储期，文件作用域和内部链接，在所有函数外部

```C
int traveler = 1;			// 外部链接
static int stayhome = 1;	// 内部链接
int main(void) {
    
   extren int traveler;  // 使用定义在别处traveler
   extren int stayhome;  // 使用定义在别处的stayhome
}
```

### 分配内存： malloc()和free()

```C
double * ptd;
int n = 30;
ptd = (double *)malloc(n * sizeof(double))
// 在C中不一定要使用强制类型转换，但在C++中需要
```

## 第十三章文件输入\输出

### 文件是什么

> 文件通常是在磁盘或固态硬盘上的一段已命名的存储区，

**所有文件的内容都要以二进制的形式储存**，

但是如果文件最初使用二进制编码的字符（ASCII）来表示文本，该文件就是文本文件，其中包含文本内容，

如果文件中的二进制值代表机器语言代码或数值数据或图片或音乐，该文件就是二进制文件，其中包含二进制内容

### getc()和putc()

#### getc() 从文件中读取字符

```C
// 设置输入流 从哪里读取
in = fopen(fileName, "r");
// 从文件中读取字符
ch = getc(in)

// 把字符输入到文件中
putc(ch, out);
```



### fprintf()和fscanf()，fgets()和fputs()

#### fprintf()

#### 普通输出到屏幕

```C
fprintf(stdout, "这是一段普通输出的文本\n");
```

#### 从xx写入到文件中

```C
FILE *fp;
char words[40] = “zhaosi shi ge da ben dan”;

if (fp = fopen("wordy", "a+") != NULL) {
	// 从字符串数组中写入到wordy文件中	
    fprintf(fp, "%s\n", words);
}
```

#### fscanf()

##### 普通从键盘中读入到XXX变量中

```C
fscanf(stdin, "%s", words);
```

##### 从文件中读入到xxx变量中

```C
rewind(fp)   // 返回到文件开始处
// 从文件中读取数据于数组中 一行一行的读取
fscanf(fp, "%s", words);
```

#### fgets()

##### 参数

> fgets()函数读取输入指导第一个换行符的后面，或读到文件结尾，或者读取STLEN-1字符，然后fgets()在末尾添加一个空字符使之成为一个字符串，如果fgets()在读到字符上限之气那已读完一整行，他会把表示行结尾的换行符放在空字符前面，fgets()在遇到EOF时，返回NULL值

+ 表示存储输入位置的地址(char * )
+ 整数 表示待输入字符串大小
+ 文件指针

```C
fgets(buf, STLEN, fp);
// buf是char类型数组名称，STLEN是字符串的大小，fp是指向FILE的指针
```

#### fputs()

##### 输出错误   

fputs("打开文件失败", stderr);

> 根据传入地址找到的字符串写入指定的文件中，在其打印字符串时，不会加入换行符

##### 参数

+ 字符串的地址
+ 文件指针

### 随机访问 fseek()和ftell()



### size_t fwrite()函数和fread()函数

> 定位到primer 结构变量开始的位置，并把结构中所有的字节都拷贝到与pbooks相关的文件中，
>
> fwrite(&primer, sizeof(struct book), 1, pbooks)
>
> 带相同参数的fread()表明从文件中拷贝一块结构大小的数据到&primer指向的位置

#### 参数

+ 源文件变量 列如一个结构体开始的位置
+ 所需拷贝的一块数据的大小
+ 表明一次拷贝一块数据
+ 文件指针





## 第十四章结构和其他数据形式

### 声明结构体

#### 普通声明

```C
struct book {
    char title[40];
    char author[40];
    float value;
}

// 初始化
struct book library = {
 	“C Promer Plus”,
    "Prata",
    88.8
};
// 或者
struct book library = {
 	.title = “C Promer Plus”,
    .author = "Prata",
    .value = 88.8
};
```

#### 带标记的简化声明

```C
struct book {
     char title[40];
    char author[40];
    float value;
} library;
```

#### 不带标记的简化声明

> 然而，如果想多次使用结构模板，就要使用代标记的形式

```C
struct {
     char title[40];
    char author[40];
    float value;
} library;
```

### 嵌套结构

```C
// 第一个结构
struct names {
    char first[40];
    char last[40]；
};

struct guy {
    struct names handle;
    char favfood[40];
    char job[40];
    float income;
}

// 初始化
struct guy fellow = {
    {"zhao", "si"},
    "hahahah",
    "youpinkejigongsi",
    68112.0
}

```

### 指向结构的指针

```C
// 接上代码的结构定义
struct guy fellow[2] = {
    {
        {"zhao", "si"},
        "hahahah",
        "youpinkejigongsi",
        68112.0
    },
   	{
        {"zhao", "si"},
        "hahahah",
        "youpinkejigongsi",
        68112.0
   	}
}

// 指向结构的指针
struct guy * guy_p = &fellow[0];  

// 通过指针访问结构体元素
printf("%s\n", guy_p->income);
printf("%s\n", guy_p->names.fister);
```

#### 结构名不是一个地址，所以需要先取地址

```C
struct guy barney;
struct guy * p_guy;
p_guy = &barney;
```

#### 用指针访问成员

+ 需要使用->
+ 不能使用.，因为p_guy不是结构名

### 向函数传递结构的信息

#### 传递结构成员

```C
double sum(double x, double y) {
    return (x + y);
}
int main(void) {
    struct funds {
        double bankfund;
        double savefund;
    } stan;
    struct stan = {
        55,
        22
    }
    
    // 直接传递数值即可，sum函数并不关心传入的时什么样的结构，他只关心传入的数据类型为double类型
    printf("%lf\n", sum(stan.bankfund, stan.savefund))
    return 0;
}
```

#### 传递结构的地址

```C
void showinfo (struct names * pt) {
    ,.......
}
int main(void) {
    struct names person;
    showinfo(&person);
    
    return 0;
}
```

#### 直接传递结构



#### 其他的结构特性

+ C允许把一个结构直接赋值给另一个结构，但是数组不能这样做

  ```C
  // 列如有相同结构的结构变量  o_data1, o_data2
  // 可以直接赋值 把o_data2中每个成员的值都赋值给了o_data1，即使成员是数组，也可以完成赋值
  o_data1 = o_data2;
  ```

+ 可以把结构初始化另外一个同类型的结构

  ```C
  struct names right_filed = {"zhao"，“si”};
  struct names left_filed = right_filed;
  ```

### 结构中的字符数组和字符指针

> 可以使用指向char的指针来代替字符数组

```C
// 使用正常的字符数组
struct names {
    char first[40];
    char last[40];
}
// 使用指向char的指针
struct pnames {
    char * fister;
    char * last;
}
// 具有潜在的危险
scanf("%s", pnamse.first);
// 指针pnamse.first的地址是未初始化的，其地址可能是任意值
```

### 结构、指针和malloc()

```C
// 使用指向char的指针
struct pnames {
    char * fister;
    char * last;
}
int main(void) {
    struct pnamse * zhaosi;
    char temp[40];
    scanf("%s", temp);
    // 分配内存地址于指针变量
    zhaosi->fister = (char *)malloc(strlen(temp) - 1);
    strcpy(zhaosi->first, temp)
}
```

### 复合字面量和结构

#### 字面量赋值给结构体变量

```c
// 模板标记names
struct names {
    char first[40];
    char last[40];
}

int main(void) {
    
   	struct names zhaosi;
    // 创建符合字面量赋值给结构体变量
    zhaosi = (struct names) {
        "zhao",
        "si"
    };
    return 0；
}
```

#### 字面量作为函数的参数

```C
// 接受结构体为参数的函数
double rect_area (struct rect t) {
    return rect.x + rect.y
}

double area = rect_area((struct rect) {10.5, 20.5});
```

### 伸缩型数组成员

+ 伸缩型数组必须是结构的最后一个成员
+ 结构中必须有一个成员
+ 伸缩数组的声明类似于普通数组，只是它的方括号是空的

```C
struct flex {
    int count;
    double average;
    double scores[];   //伸缩型数组成员
}
```

#### 使用

```C
// 声明此结构类型指针
struct flex * pf1;
int n = 5;
// 为结构和数组分配空间
// 一个结构体的空间和长度为n的数组的空间，类型为double
pf1 = malloc(sizeof(struct flex) + n * sizeof(double));
// 可以进行赋值和使用
。。。。。。。。。。。
// n 进行了改编
// 重新开辟空间
pf2 = malloc(sizeof(struct flex) + n * sizeof(double))

```

### 联合



