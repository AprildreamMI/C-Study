# C语言 C 

## 第一章

### 使用C语言的7个步骤

#### 第一步：定义程序的目标

#### 第二步：	设计程序

#### 第三步:	编写代码

#### 第四步：	编译代码

​	通过以下的操作操作，生成一个用户可以运行的可执行文件

##### 编译器

​	编译器就是把源代码转换成可执行代码的程序

> 可执行代码使用计算机的及其语言表示的代码，这种语言有数字表示的指令组成

##### 连接器

​	C编译器还将源代码与C库的代码合并成最终的程序

> 应该是有一个被称为链接器的程序来链接库函数

#### 第五步：	运行

### 目标代码文件、可执行文件、库

> c 语言的策略是把源代码变成为可执行文件
>
> 进行编译生成  中间代码   并且通过链接器来链接其他库文件，其他的库文件也是中间代码，合并后，生成可执行文件

#### 目标代码文件（中间代码的一种表现形式）

​	把源代码转换成机器语言代码，并把结果放在目标代码文件

##### 虽然包含机器代码：并不能直接运行	

> 因为目标文件存储的是编译器翻译的源代码，这还不是一个完成的程序

+ 缺失启动代码，启动代码充当程序与操作系统中间的接口
+ 缺失库函数， 只是包含了使用库函数的指令，真正的代码，存储在另外一个被称为库的文件中

#### 库

​	函数库，库文件中有许多函数的目标代码

#### 可执行文件

##### 链接器的作用

链接

+ 自己编写的代码通过编译器转换的目标代码

+ 系统的标准启动代码

+ 库代码

  > 对于库代码，链接器指挥吧程序中要用到的库函数提取出来

合并，为一个文件  可执行文件

#### 目标代码文件和可执行代码文件的对比

##### 相同点

+ 目标代码文件和可执行代码文件都有机器语言指令组成

区别

+ 目标代码文件中只包含编译器为你自己编译的机器语言代码
+ 可执行文件中还包含你编写的程序中使用的库函数和启动代码的机器代码

### 变量的命名

#### 规则

​	 可以使用大小写字母，数字和下划线来命名，并且，名称的第一个字符必须是字符或下划线，不能是数字（不能是特殊的符号）

## 第三章

### 八进制和十六进制

#### 十六进制

0x 或 0X前缀表示十六进制

### 八进制

0 是八进制

### 各类进制显示

> 如果要显示的打印前缀， 则需要在%后面加一个#号
>
> %#o
>
> %#x
>
> %#X

+ 十进制

  > %d

+ 八进制

  > %o

+ 十六进制

  > %x

#### 各整数类型

> 带** 号的都是有符号的类型

+ ** int

  > 16位或者32位
  >
  > 根据计算机的自然字长而定

+ ** short int 类型  

  > 16

+ ** long int

  > 32

+ ** long long int

  > 该类型至少占64位

+ unsigned int   || unsigned

  > 非负数 无符号整形
  >
  > 他可以比有符号的表示更大的数
  >
  > 0 ~ 65535

+ signed 

  > 在任何类型前 加上其 表示 强制使用有符号

### 各类型的打印格式

+ unsigned

  > %u

+ long int

  > %ld
  >
  > 还可以通过八进制和十六进制来表示Long int 
  >
  > 在转换说明汇总， 只能用小写

  + 八进制 Long

    %lo

  + 十六进制 Long

    %lx

+ long long 

  > %lld

+ short 

  > %hd

+ unsigned long

  > %lu

### char

> 一字节 === 8位

char 占一字节八位存储单元

#### 字符变量在C语言中被视为 int 类型， 而不是 char 类型

```
char myChar  = 'A' // 'A' 字符变量在ASCII 表中是65， 所以是int 类型
```

### float

#### 范围

10-37 ~ 10+37

#### 有效数字

foat 类型必须能够表示33。333333的前六位数字，而不是精确到小输掉后六位

### double

#### 范围

10-37 ~ 10+37

#### 有效数字

doble 类型必须能够表示33。3333333333的前 十 位数字，而不是精确到小输掉后六位

### 浮点型常量

> 默认情况下，编译器假定浮点型常量是double 类型的精度
>
> ```c
> // 加色some 是float类型的变量
> float some = 4.0 * 2.0;
> /*
> 	通常，4.0 和 2.0 被储存为双精度的double 类型
> 	使用双精度进行还曾发运算，然后将乘积截断，成float
> 	在浮点书后面加上f 或者 F ，来覆盖默认的double
> */
> a = 5.22F
> 
> d = 5.33L // 双精度的表示6+
> ```
>

## 第四章

### 字符串

> C 语言中没有专门用于存储字符串的变量类型，字符串都被存储在char类型的数组中、

#### 空字符

> 数组的末尾位置，是 '\0'，这是空字符， 表示结尾 ASCII 妈等于 0

+ C语言中的字符串一定一空字符结尾
+ 数组的容量必须至少比带存储字符串中的字符数多1,

#### 字符穿和字符

##### 区别

+ ‘x' 是基本类型，“x”是派生类型（char 数组）
+ “x” 实际上由两个字符组成，’x' 和 '\0'

#### Strlen() 函数

> Strlen () 函数，给出字符串中的字符长度

##### sizeof() 运算符

> 他以字节为单位，输出对象的大小

#### 实列

```
#define pw asdzxc456
char name[40];

输入：zhaosi lvmi

// 虽然输入了8个字符，但因为在字符数组中存储时，中间有一个空字符，所以就中断了计数，
// 只计算空字符前的字符
strlen(name): 4
// 因为字符数组中定义的是40个字节，一个字符占用一字节
sizeof(name): 40

// 遇到空字符就停止计数
strlen(pw): 9
// 多了一个空字符的字节
sizeof(pw): 10
```

```
// 对于中文 一个中文占用两个字符，也就是两个字节
对于name输入： 赵思

strlen(name): 4
```

### #define 预处理器

```c
#define age 22
/*
	编译程序的时候，程序中所有的age将被替换成22
	这一过程叫i做
	编译时替换
	如此定义变量，也叫
	明示变量
*/
```

### printf () 和 scanf() 函数

#### printf() 函数

```
printf("字符串为：%c, 整形数字为%d", '$', 2 * 10);
/*
	像%c,这类，叫做 转换说明，逗哈之后的值，是待打印项列表
	printf待打印项列表使用的是值，无论变量还是常量
*/
```

#### 修饰符合标记

```
-： 左对齐
+： 显示正负号
空格： 正号就是空格， 负号就是-
#： 转换成另外一种形式的写法，如果是%o， 就转换为0开头的，如果是%x则转换为ox开头的
0: 对数值格式，使用0来代替空格填充字段宽度
```

#### scanf() 函数

> 返回成功读取项的数量

##### 跳过空白匹配

scanf() 函数使用空白（换行符，制表符合空格）把输入分成多个字段，再一次把转换说明和字段匹配时跳过空白，

##### scanf()读取一个%d整数的过程

###### 假设scanf() 根据%d的转换说明读取一个整数，

- scanf()每次读取一个字符，跳过所有的空白字符，直到遇到第一个非空白字符才开始读取
- 因要读取整数，所以scanf()希望发现一个数字字符或者一个符号[+、-]
- 如果找到一个字符是数字，它便保存改数字并读取下一个字符，不断的读取和保存字符，直至遇到非数字的字符
- 如果遇到一个非数字的字符，它便认为读取到了整数的结尾，
- 然后，scanf() 把非数字字符放回输入
- 这意味着程序下一次读取输入时，首先读到的是上一次读取丢弃的非数字字符
- 最后，scanf() 计算已读取数字的相应数值，并将计算后的值放入指定的变量中

##### scnaf()和printf()中*的使用

> 在printf()中使用通过变量定义输出的字段宽度

```
#include <stdio.h>
int main(void) {
  unsigned width, precision;
  int number = 256;
  double weight = 242.5;

  printf("请输入字段宽度：\n");
  scanf("%d", &width);
  printf("number:%*d\n", width, number);

  printf("请输入字段宽度和小数点精度：\n");
  scanf("%d %d",&width, &precision);
  printf("Weight = %*.*f\n", width, precision, weight);


  return 0;
}
```

> scanf() 中使用，则为定义了*的转换格式跳过

```
  int n;
  printf("程序会跳过两个输入，使用最后一个输入赋值给n：");

  scanf("%*d %*d %d", &n);
  printf("N的值为: %d", n);
```

## 第八章 字符输入/输出和输入验证

### io函数

> printf()、scanf()、getchar()、putchar()、·-

#### getchar()

返回值：int类型

如果把getchar()的返回值赋给char类型的变量，以谢编译器会警告可能丢失数据

getchar() 读取每个字符，包括空格、制表符和换行符，而scanf()在读取数字指定的行数和列数打印该字符

## 第十章

### 数组

#### 指定初始化器

```
// 可以在初始化列表中使用带方括号的下标指明待初始化的元素
int arr[6] = {[5] = 212};
// 把arr[5] 初始化为212
对于一般的初始化，在初始化一个元素后，为初始化的元素都会被设置为0

如果未指定元素大小会如何？
int stuff[] = {1, 2, 3, [6] = 23}
int staff[] = {1, [6] = 4, 9, 10}

编译器会把数组的大小设置未足够装得下初始化的值，所以，stuff数组有7个元素，编号围殴0 ~ 6，
而staff数组的元素比stuff数组多两个
```

C不允许把数组作为一个单元付给另外一个数组，除非初始化以外页不允许使用花括号列表的形式赋值

### 数组名是数组首元素的地址

```
/*
	flizny 和 &fizny[0] 都表示数组首元素的内存地址，两者都是常量
*/
flizny == &fizny[0]
```

### 指针 + 1 , 实际上是增加了一个存储单元

> 指针的值递增它所指向类型的大小（以字节为单位）

```
short dates[5];
short * pti

// 把数组地址复制给指针
pti = dataes;

pti + 0: 0x7fff5fbff8dc
pti + 1: 0x7fff5fbff8de
pti + 2: 0x7fff5fbff8e0
pti + 3: 0x7fff5fbff8e2
```

​	在我们系统中，地址按字节编址 short 类型占用2字节

​	在C语言中 指针 + 1 就是增加一个存储单元，对数组而言，这意味着把 + 1 后的地址是下一个元素的地址，而不是下一个字节的地址

#### 自增指针指向

```
total += *start++

一元运算符*和++的优先级相同，但结合律收从右往左，所以start++先求值，然后才是*start，也就是说，执政start先递增后只想，但由于使用后缀表达式，意味着先把执政只想位置上的值加到total上，然后再递增指针，如果使用*++start,则相反，先递增指针，再使用指针指向位置上的值，如果使用（*start）++，则先使用start指向的值，再递增该值，而不是递增指针
虽然*start++的写法比较常见，但是*（start++）这样写更清楚，
```



### 使用const 来保护数据 以及和数组、 指针的关系

#### const 关键字保护数组

```
const int days[5] = {1, 2, 3, 4, 5}

// 编译出错. 不允许更改
days[2] = 44;
```

#### 指向const 的指针不能用于改变他所指向的地址中的值，但是可以修改指向地址（指向别处）

> void show_array(const * pd, int end)
>
> 表明该函数不会使用指针改变数据

```
double rates[5] = {1, 2, 3, 4, 5}
// pd 指向数组的首元素 
// 把pd 指向的double 类型的值声明为const 
const double * pd = rates;

*pd = 29.89   // 不允许, 企图修改首地址的值 
pd[2] = 222.22   // 不允许，因为pd相当于就是首地址，相当于rates ，编译器不允许通过这种方式来进行修改
rates[0] = 99.99  // 允许
pd++              // 允许
```

#### 把const 数据 或 非 const 数据的地址初始化为指向const 的指针或为其赋值是合法的

```
double rates[5] = {1, 2, 3, 4, 5}
const double locked[4] = {0.08, 0.075, 0.0512, 0.611}

const double * pc = rates   // 合法
pc = locked    				// 合法
pc = &rates[3]				// 合法
```

#### 只能把非const 的数据赋给普通指针

> 否则， 通过指针就能改变const 关键字的数据

```
double rates[5] = {1, 2, 3, 4, 5}
const double locked[4] = {0.08, 0.075, 0.0512, 0.611}

double * pc = rates   		// 合法
pc = locked    				// 非法
pc = &rates[3]				// 合法
```

#### 声明一个不能修改指向地址的内容并不能改变指向的指针

```
double rates[5] = {1, 2, 3, 4, 5}
const double locked[4] = {0.08, 0.075, 0.0512, 0.611}

const double * const pc = rates   		// 合法
pc = &rates[2]    						// 非法
*pc = 56.56								// 合法
```

### 指针和多位数组

```
int zippo[4][2]    		// 内含int 数组的数组
```

+ 数组名

  > zippo 是该数组首元素的地址

+ 首元素

  > zippo首元素是一个内含两个int 值的数组， 所以 zippo 是这个内含两个int 值的数组的地址

1. 因为zippo是数组首元素的地址，所以zippo的值和&zippo[0]的值相同，

   而zippo[0]是一个内含两个元素的数组, 所以，他又是他的首元素的地址

   所以zippo[0] ==` &zippo[0][0]`

   

   因为，二维数组在内存中也是连续性的存储，列如`int arr[2][2]`

   | `zippo[0][0]` | `zippo[0][1]` | `zippo[1][0]` | `zippo[1][1]` |
   | ------------- | ------------- | ------------- | ------------- |
   |               |               |               |               |

   arr: 是二维数组的首元素是一个一个数组，这个数组存储两个int 类型的元素 所以 其为 8字节（占用两个int 大小对象的地址

   `arr[0]`： 是一维数组的首元素的地址，为一个int 类型的值 （4字节）

2. *zppo: 代表该数组首元素（zippo[0]的值，但是zippo[0] 本身是一个Int 类型的值的地址 == `&zippo[0][0]`）

   所以  *zippo == `&zippo[0][0]`

   所以 对于 `zippo[2][3]` = { {1,2,3}, {2,3,4}}

   zippo == &zippo[0]

   *zippo ==  zippo[0] == `&zippo[0][0]`

   **zippo  = *(`&zippo[0][0]`)  == 1

### 变长数组

> 变长数组不能改变大小
>
> 变长数组中的“变”不是指可以修改已创建数组的大小，一旦创建了变长数组，他的大小则保持不变，这里的变是指，在创建数组时，可以使用变量指定的数组的维度上

## 第十一章

### 字符串数组和初始化

#### 字符串数组初始化

```c
// 字符串数组
const char ml[40] = "Limit yourself to one line's worth"；
// 让编译器自动计算大小
const char ml[] = "Limit yourself to one line's worth"；
```

> 让编译器自动计算大小只能用在初始化数组时，如果创建一个稍后在填充的数组，就必须在声明时指定大小

#### 指针表示法创建字符串

```
const char * pt1 = "Something is pointing at me"；
```

### 数组表示字符串和指针表示字符串的不同

```C
const char arl[] = "Something is pointing at me";
```

#### 数组形式

1. 在计算机的内存中分配为一个内涵29个元素的数组
2. 每个数组元素被初始化为字符串字面量对应的字符
3. 字符串作为可执行文件的一部分被存储在数据段中，当把程序载入内存时，也载入了程序中的字符串
4. 字符串存储在静态存储区
5. 程序在开始运行时才会为该数组分配内存，此时，才将字符串拷贝到数组中
6. 此时字符串有两个副本，
   1. 在静态内存中的字符串字面量
   2. 存储在ar1数组中的字符串
7. 此后，编译器便把数组名ar1识别为该数组首元素地址别名，在数组形式中，ar1是地址常量，不能更改ar1，如果改变了ar1则意味改变了数组的存储位置
8. 可以进行ar1+1这样的操作，表示数组下一个元素
9. 但不允许ar++这样的操作

#### 指针形式

1. 也使得编译器为字符串在静态存储区预留29个元素的空间
2. 一旦开始执行程序，他就会为指针变量pt1留出一个存储位置，并把字符串的地址存储在指针变量中
3. 改指针变量最初指向改字符串的首字符，但是它的值是可以改变的

### 字符串的输入 fgets() and gets()

##### 注意

​	字符串的输入第一件事要为其分配空间，以存储稍后读入的字符串，然后用输入函数获取该字符串

​	不要指望计算机读取字符串时，顺便计算它的长度，然后在分配空间

``` C
char * name;
scanf("%s", name);
/*
  虽然会通过编译，但在读入name时，name可能会擦写掉程序中的其他数据和代码，从而导致程序崩溃
  因为scanf() 要把信息拷贝至参数指定的地址上，而此时该参数为一个未初始化的指针，name 可能会指向任何地方
*/
```

#### gets ()

> 读取整行输入，直至遇到换行符，然后丢弃换行符，存储其余字符串，并在结尾添加一个空字符 ‘\0’ 以标志结尾

##### 参数

+ 字符数组、

##### 返回

- 因为是读取一个文件
- 一切顺利，文件读完了，则返回一个 null 
- 出现错误， 返回一个 null

##### 处理方法

+ 整行读取，遇到换行符结束
+ 丢弃换行符
+ 存储其余字符
+ 在结尾添加一个 ‘\0’ 标志结尾
+ 无法检查数组是否装得下输入行，只知道数组的开始处，并不知道数组中有多少个元素
+ 输入过长，导入溢出，多余的字符使用了尚未使用了其他内存空间，容易崩溃

#### fgets()

##### 参数

+ 字符数组
+ 读入字符的最大数量，没有读到最大数量，则读到换行符为止
+ 指明要读取的文件，如果不是文件是键盘，则 为 `stdin` 在stdio.h文件中定义

##### 返回

+ 因为是读取一个文件
+ 一切顺利，文件读完了，则返回一个 null 
+ 出现错误， 返回一个 null

##### 处理方法

+ 整行读取，直到读完遇到null（针对文件）
+ 保存换行符
+ 通过第二个参数来规定读取的最大数量
+ 输入过长，只保留有效字符

#### scanf()

##### 参数

+ 转换说明
  + 如果规定了宽度，则按宽度读取或读到的第一个空白字符停止
  + 输入超过了宽度 存入缓冲区，等待下一次读取
+ 需存入的地址

##### 返回

+ 整数：scanf()成功读取到了项数
+ EOF：文件结尾

##### 处理方法

+ 从第一个非空白字符作为开始
+ 遇到的第一个空白字符作为结束

### 字符串的输出

#### puts()

##### 参数

+ 字符串的地址

##### 处理过程

+ 自动在所显示的字符串后面添加一个换行符，因为在gets() 中舍弃换行符

+ 遇到空白符停止

  + ```
    char side_a = ['w', 'a', 'c']；
    // 上字符数组没有空白符 `\0` 所以不会停， 一直向后内存读取，直到遇到一个空白符
    ```

#### fputs()

##### 参数

+ 字符数组（地址）
+ 要写入数据的文件，如果要显示在显示屏上 则传入`stdout`

##### 处理过程

+ 不会添加换行符，因为在fgets() 保留有换行符88



